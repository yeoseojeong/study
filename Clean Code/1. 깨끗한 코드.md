# 1장 깨끗한 코드
코드 -> 요구사항을 상세히 표현하는 수단

제대로 명시한 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋음

<나쁜 코드>

르블랑의 법칙 -> 나중은 결코 오지 않는다.

나쁜 코드는 개발 속도를 계속해서 떨어뜨림
나쁜 코드가 쌓일수록 팀 생산성은 떨어지다가 결국 0에 근접
-> 생산성이 떨어지면 관리층은 나름대로 복구하기 위해 노력함
->생산성을 증가시키려는 희망을 품고 프로젝트에 인력을 추가로 투입하지만 시스템 설계에 대한 조예가 깊지 않고 압력에 시달리다 결국 더 나쁜 코드를 양산(거의 0)



생산성이 떨어졌기에 자연스럽게 재설계를 요구하며 두 부류로 나뉨
재설계를 하는 팀(유능하고 똑똑한 사람들이 차출됨) vs 시스템 유지보수 팀

기한을 맞추는 유일한 방법-> 깨끗한 코드를 유지하는 습관

깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 하여 깨끗한 코드를 작성할 줄 안다는 뜻은 아님

깨끗한 코드란?

<<비야네 스트롭스투룹 / c++ 창시자 & the c++ programming language 저자>>
우아하고 효율적인 코드 (우아함: 외양이나 태도가 기품있고  단아하며 보기에 즐거운 / '보기에 즐거운' 코드를 뜻함)
논리가 간단해야 버그가 숨어들지 못함
의존성을 최대한 줄여야 유지보수가 쉬워짐
오류는 명백한 전략에 의거해 철저히 처리함 (세세한 사항까지 꼼꼼하게 신경 쓰라는 의미)
깨끗한 코드는 한가지를 제대로 함

<<그래디 부치 / object oriented analysis and design with application 저자 >>
단순하고 직접적
잘 쓴 문장처럼 읽힘 (가독성을 강조)
설계자의 의도를 숨기지 않음
명쾌한 추상화와 단순한 제어문으로 가득

코드는 추측이 아니라 사실에 기반 해야함
반드시 필요한 내용만 담아야 함 (코드를 읽는 사람에게 프로그래머의 단호함을 줘야 함)

<<큰 데이브 토마스 / OTI 창립자 & 이클립스 전략의 대부>>
작성자가 아닌 사람도 읽기 쉽고 고치기 쉬움
단위 테스트 케이스와 인수 테스트 케이스 존재
특정 목적을 달성하는 방법은 하나만 제공
의존성은 최소이며 각 의존성을 명확히 정의
API는 명확하고 최소로 줄임
언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기 때문에 코드는 문학적으로 표현


<<마이클 패더스 / working effectively with legacy code 저자>>
언제나 누군가 주의 깊게 짰다는 느낌을 줌
작성자가 이미 모든 사항을 고려했으므로, 고치려고 살펴봐도 딱히 손댈 곳이 없음

<<론 제프리스 / extreme programming installed와 extreme programming adventure in C# 저자>>
모든 테스트 케이스 통과
중복이 없음
시스템 내 모든 설계 아이디어를 표현
클래스, 메서드, 함수 등을 최대한 줄임

객체가 여러 기능을 수행한다면 여러 객체로 나눔
메서드가 여러 기능을 수행한다면 '메서드 추출 리펙터링 기법'을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눔
 
중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기.

<<워드 커닝햄 / Wiki 창시자 & 익스트림 프로그래밍 공동 창시자 & 디자인 패턴을 뒤에서 움직이는 전문가, 스몰토크와 객체 지향의 정신적 지도자 & 코드를 사랑하는 프로그래머들의 대부>>

코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드
코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드

놀랄 일이 없어야 됨, 코드를 독해하느라 머리를 쥐어짜지 않아야 됨, 명백하고 단순


<<저자 (밥아저씨)>>
우리는 끊임없이 기존 코드를 읽어야하므로, 읽기 쉬운 코드가 중요
주변 코드가 쉬우면 새 코드를 짜기도 쉬움

	- 보이스카우트 규칙
	시간이 지나도 언제나 깨끗하게 유지해야 함
	- 프리퀄과 원칙
![image](https://github.com/yeoseojeong/study/assets/121150215/a93c7b82-6e50-4e6c-bb5e-94e7e437aec8)
